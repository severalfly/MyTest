观察者模式
=

总体还类似中介者模式，细微差别还需要时间来理解。  
观察者模式有一个观察者类（司机），一个目标类（红绿灯）组成，红绿灯可以增加很多司机观察，在这个简单模型中，一个司机只能观察一个红绿灯。

java 中 `Observer` 接口可以声明一个观察者类  
继承 `Observable` 类，可以声明一个目标类

观察者模式中，目标类的实现相对复杂，需要`setChange()`，再显式调用`notifyObservers()` 来通知所有观察者，观察者此时会各自执行 `update` 方法

优点
=
1. 可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色；
2. 在观察者和观察目标之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次；
3. 支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度；
4. 满足开闭原则的要求，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下，增加新的观察目标也很方便。

缺点
=
1. 如果一个观察目标对象有很多直接和间接观察者，将观察者都通知到会花费很多时间；；
2. 如果在观察者和观察目标之间存在循环依赖，观察目标会触发他们之间进行循环调用，可能导致系统崩溃；
3. 没有相应机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。